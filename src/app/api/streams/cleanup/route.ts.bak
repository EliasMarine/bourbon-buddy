import { NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import { getCurrentUser } from '@/lib/supabase-auth';
// Removed runTransaction import as we'll execute sequentially
// import { runTransaction } from '@/lib/prisma-transaction-fix';
// Removed authOptions import - not needed with Supabase Auth;

// Constants for stream cleanup
const CLEANUP_PERIODS = {
  STALE_LIVE: 1 * 60 * 60 * 1000,     // 1 hour for live streams
  INACTIVE: 1 * 60 * 60 * 1000,       // 1 hour for inactive streams
  COMPLETED: 1 * 60 * 60 * 1000       // 1 hour for completed streams
};

// POST /api/streams/cleanup - Clean up stale streams
// This endpoint should be called by a cron job every hour
export async function POST(request: Request) {
  // Initialize Supabase client
  const supabase = await createClient();

  try {
    // Check for authorization - only allow authenticated users or internal calls
    const user = await getCurrentUser();
    
    // Check if request is from the app itself (internal cleanup)
    const isInternalRequest = request.headers.get('x-internal-request') === process.env.INTERNAL_API_SECRET;
    
    // If not an internal request and no session, reject
    if (!isInternalRequest && !user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const now = new Date();
    const staleThreshold = new Date(now.getTime() - CLEANUP_PERIODS.STALE_LIVE);
    const inactiveThreshold = new Date(now.getTime() - CLEANUP_PERIODS.INACTIVE);

    let staleLiveCount = 0;
    let deletedCount = 0;

    try {
      // Operation 1: Mark stale live streams as not live (outside transaction)
      console.log(`[cleanup] Marking streams started before ${staleThreshold.toISOString()} as not live.`);
      const staleLiveResult = await prisma.stream.updateMany({
        where: {
          isLive: true,
          startedAt: {
            lt: staleThreshold
          }
        },
        data: {
          isLive: false
        }
      });
      staleLiveCount = staleLiveResult.count;
      console.log(`[cleanup] Marked ${staleLiveCount} streams as not live.`);

    } catch (updateError) {
      console.error('[cleanup] Error updating stale live streams:', updateError);
      // Decide if we should continue or stop - let's continue for now
    }
    
    try {
      // Operation 2: Delete old inactive streams (outside transaction)
      console.log(`[cleanup] Deleting inactive streams started before ${inactiveThreshold.toISOString()}.`);
      const deletedResult = await prisma.stream.deleteMany({
        where: {
          isLive: false,
          startedAt: {
            lt: inactiveThreshold
          }
        }
      });
      deletedCount = deletedResult.count;
      console.log(`[cleanup] Deleted ${deletedCount} old inactive streams.`);
      
    } catch (deleteError) {
      console.error('[cleanup] Error deleting old inactive streams:', deleteError);
      // Log error but don't fail the entire request if only deletion failed
    }

    return NextResponse.json({
      success: true,
      staleLiveCount: staleLiveCount,
      deletedCount: deletedCount,
      message: `Cleaned up ${staleLiveCount} stale live streams and deleted ${deletedCount} old streams`
    });
  } catch (error) {
    // General catch block for errors outside the specific operations
    console.error('Stream cleanup error:', error);
    return NextResponse.json(
      { 
        error: 'Internal server error', 
        details: error instanceof Error ? error.message : String(error) 
      },
      { status: 500 }
    );
  }
} 